'use strict';

exports.__esModule = true;
exports.CASE_SENSITIVE_FS = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.relative = relative;
exports.default = resolve;

require('es6-symbol/implement');

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _es6Set = require('es6-set');

var _es6Set2 = _interopRequireDefault(_es6Set);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _pkgDir = require('pkg-dir');

var _pkgDir2 = _interopRequireDefault(_pkgDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _crypto = require('crypto');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CASE_SENSITIVE_FS = exports.CASE_SENSITIVE_FS = !_fs2.default.existsSync(path.join(__dirname, 'reSOLVE.js'));

var fileExistsCache = new _es6Map2.default();

function cachePath(cacheKey, result) {
  fileExistsCache.set(cacheKey, { result: result, lastSeen: Date.now() });
}

function checkCache(cacheKey, _ref) {
  var lifetime = _ref.lifetime;

  if (fileExistsCache.has(cacheKey)) {
    var _fileExistsCache$get = fileExistsCache.get(cacheKey);

    var result = _fileExistsCache$get.result;
    var lastSeen = _fileExistsCache$get.lastSeen;
    // check fresness

    if (Date.now() - lastSeen < lifetime * 1000) return result;
  }
  // cache miss
  return undefined;
}

// http://stackoverflow.com/a/27382838
function fileExistsWithCaseSync(filepath, cacheSettings) {
  // don't care if the FS is case-sensitive
  if (CASE_SENSITIVE_FS) return true;

  // null means it resolved to a builtin
  if (filepath === null) return true;

  var dir = path.dirname(filepath);

  var result = checkCache(filepath, cacheSettings);
  if (result != null) return result;

  // base case
  if (dir === '/' || dir === '.' || /^[A-Z]:\\$/i.test(dir)) {
    result = true;
  } else {
    var filenames = _fs2.default.readdirSync(dir);
    if (filenames.indexOf(path.basename(filepath)) === -1) {
      result = false;
    } else {
      result = fileExistsWithCaseSync(dir, cacheSettings);
    }
  }
  cachePath(filepath, result);
  return result;
}

function relative(modulePath, sourceFile, settings) {

  var sourceDir = path.dirname(sourceFile),
      cacheKey = sourceDir + hashObject(settings) + modulePath;

  var cacheSettings = (0, _objectAssign2.default)({
    lifetime: 30 }, // seconds
  settings['import/cache']);

  // parse infinity
  if (cacheSettings.lifetime === 'âˆž' || cacheSettings.lifetime === 'Infinity') {
    cacheSettings.lifetime = Infinity;
  }

  var cachedPath = checkCache(cacheKey, cacheSettings);
  if (cachedPath !== undefined) return cachedPath;

  function cache(resolvedPath) {
    cachePath(cacheKey, resolvedPath);
    return resolvedPath;
  }

  function withResolver(resolver, config) {

    function v1() {
      try {
        var resolved = resolver.resolveImport(modulePath, sourceFile, config);
        if (resolved === undefined) return { found: false };
        return { found: true, path: resolved };
      } catch (err) {
        return { found: false };
      }
    }

    function v2() {
      return resolver.resolve(modulePath, sourceFile, config);
    }

    switch (resolver.interfaceVersion) {
      case 2:
        return v2();

      default:
      case 1:
        return v1();
    }
  }

  var configResolvers = settings['import/resolver'] || { 'node': settings['import/resolve'] }; // backward compatibility

  var resolvers = resolverReducer(configResolvers, new _es6Map2.default());

  for (var _iterator = resolvers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref2;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref2 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref2 = _i.value;
    }

    var _ref3 = _ref2;
    var name = _ref3[0];
    var config = _ref3[1];

    var resolver = requireResolver(name, sourceFile);

    var _withResolver = withResolver(resolver, config);

    var fullPath = _withResolver.path;
    var found = _withResolver.found;

    // resolvers imply file existence, this double-check just ensures the case matches

    if (found && !fileExistsWithCaseSync(fullPath, cacheSettings)) {
      // reject resolved path
      fullPath = undefined;
    }

    if (found) return cache(fullPath);
  }

  return cache(undefined);
}

function resolverReducer(resolvers, map) {
  if (resolvers instanceof Array) {
    resolvers.forEach(function (r) {
      return resolverReducer(r, map);
    });
    return map;
  }

  if (typeof resolvers === 'string') {
    map.set(resolvers, null);
    return map;
  }

  if ((typeof resolvers === 'undefined' ? 'undefined' : _typeof(resolvers)) === 'object') {
    for (var key in resolvers) {
      map.set(key, resolvers[key]);
    }
    return map;
  }

  throw new Error('invalid resolver config');
}

function requireResolver(name, sourceFile) {
  // Try to resolve package with conventional name
  try {
    return require('eslint-import-resolver-' + name);
  } catch (err) {} /* continue */

  // Try to resolve package with custom name (@myorg/resolver-name)
  try {
    return require(name);
  } catch (err) {} /* continue */

  // Try to resolve package with path, relative to closest package.json
  // or current working directory
  try {
    var baseDir = _pkgDir2.default.sync(sourceFile) || process.cwd();
    // absolute paths ignore base, so this covers both
    return require(path.resolve(baseDir, name));
  } catch (err) {} /* continue */

  // all else failed
  throw new Error('unable to load resolver "' + name + '".');
}

var erroredContexts = new _es6Set2.default();

/**
 * Given
 * @param  {string} p - module path
 * @param  {object} context - ESLint context
 * @return {string} - the full module filesystem path;
 *                    null if package is core;
 *                    undefined if not found
 */
function resolve(p, context) {
  try {
    return relative(p, context.getFilename(), context.settings);
  } catch (err) {
    if (!erroredContexts.has(context)) {
      context.report({
        message: 'Resolve error: ' + err.message,
        loc: { line: 1, col: 0 }
      });
      erroredContexts.add(context);
    }
  }
}
resolve.relative = relative;

function hashObject(object) {
  var settingsShasum = (0, _crypto.createHash)('sha1');
  settingsShasum.update(JSON.stringify(object));
  return settingsShasum.digest('hex');
}
//# sourceMappingURL=data:application/json;base64,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LEdBQVIsRUFBM0I7O0FBRGQsV0FHSyxRQUFRLEtBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsSUFBdEIsQ0FBUixDQUFQLENBSEU7R0FBSixDQUlFLE9BQU8sR0FBUCxFQUFZOzs7QUFBWixRQUdJLElBQUksS0FBSiwrQkFBc0MsV0FBdEMsQ0FBTixDQXBCeUM7Q0FBM0M7O0FBdUJBLElBQU0sa0JBQWtCLHNCQUFsQjs7Ozs7Ozs7OztBQVVTLFNBQVMsT0FBVCxDQUFpQixDQUFqQixFQUFvQixPQUFwQixFQUE2QjtBQUMxQyxNQUFJO0FBQ0YsV0FBTyxTQUFVLENBQVYsRUFDVSxRQUFRLFdBQVIsRUFEVixFQUVVLFFBQVEsUUFBUixDQUZqQixDQURFO0dBQUosQ0FLRSxPQUFPLEdBQVAsRUFBWTtBQUNaLFFBQUksQ0FBQyxnQkFBZ0IsR0FBaEIsQ0FBb0IsT0FBcEIsQ0FBRCxFQUErQjtBQUNqQyxjQUFRLE1BQVIsQ0FBZTtBQUNiLHFDQUEyQixJQUFJLE9BQUo7QUFDM0IsYUFBSyxFQUFFLE1BQU0sQ0FBTixFQUFTLEtBQUssQ0FBTCxFQUFoQjtPQUZGLEVBRGlDO0FBS2pDLHNCQUFnQixHQUFoQixDQUFvQixPQUFwQixFQUxpQztLQUFuQztHQURBO0NBTlc7QUFnQmYsUUFBUSxRQUFSLEdBQW1CLFFBQW5COztBQUlBLFNBQVMsVUFBVCxDQUFvQixNQUFwQixFQUE0QjtBQUMxQixNQUFNLGlCQUFpQix3QkFBVyxNQUFYLENBQWpCLENBRG9CO0FBRTFCLGlCQUFlLE1BQWYsQ0FBc0IsS0FBSyxTQUFMLENBQWUsTUFBZixDQUF0QixFQUYwQjtBQUcxQixTQUFPLGVBQWUsTUFBZixDQUFzQixLQUF0QixDQUFQLENBSDBCO0NBQTVCIiwiZmlsZSI6ImNvcmUvcmVzb2x2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnZXM2LXN5bWJvbC9pbXBsZW1lbnQnXG5pbXBvcnQgTWFwIGZyb20gJ2VzNi1tYXAnXG5pbXBvcnQgU2V0IGZyb20gJ2VzNi1zZXQnXG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nXG5pbXBvcnQgcGtnRGlyIGZyb20gJ3BrZy1kaXInXG5cbmltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcblxuZXhwb3J0IGNvbnN0IENBU0VfU0VOU0lUSVZFX0ZTID0gIWZzLmV4aXN0c1N5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgJ3JlU09MVkUuanMnKSlcblxuY29uc3QgZmlsZUV4aXN0c0NhY2hlID0gbmV3IE1hcCgpXG5cbmZ1bmN0aW9uIGNhY2hlUGF0aChjYWNoZUtleSwgcmVzdWx0KSB7XG4gIGZpbGVFeGlzdHNDYWNoZS5zZXQoY2FjaGVLZXksIHsgcmVzdWx0LCBsYXN0U2VlbjogRGF0ZS5ub3coKSB9KVxufVxuXG5mdW5jdGlvbiBjaGVja0NhY2hlKGNhY2hlS2V5LCB7IGxpZmV0aW1lIH0pIHtcbiAgaWYgKGZpbGVFeGlzdHNDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgY29uc3QgeyByZXN1bHQsIGxhc3RTZWVuIH0gPSBmaWxlRXhpc3RzQ2FjaGUuZ2V0KGNhY2hlS2V5KVxuICAgIC8vIGNoZWNrIGZyZXNuZXNzXG4gICAgaWYgKERhdGUubm93KCkgLSBsYXN0U2VlbiA8IChsaWZldGltZSAqIDEwMDApKSByZXR1cm4gcmVzdWx0XG4gIH1cbiAgLy8gY2FjaGUgbWlzc1xuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MzgyODM4XG5mdW5jdGlvbiBmaWxlRXhpc3RzV2l0aENhc2VTeW5jKGZpbGVwYXRoLCBjYWNoZVNldHRpbmdzKSB7XG4gIC8vIGRvbid0IGNhcmUgaWYgdGhlIEZTIGlzIGNhc2Utc2Vuc2l0aXZlXG4gIGlmIChDQVNFX1NFTlNJVElWRV9GUykgcmV0dXJuIHRydWVcblxuICAvLyBudWxsIG1lYW5zIGl0IHJlc29sdmVkIHRvIGEgYnVpbHRpblxuICBpZiAoZmlsZXBhdGggPT09IG51bGwpIHJldHVybiB0cnVlXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGVwYXRoKVxuXG4gIGxldCByZXN1bHQgPSBjaGVja0NhY2hlKGZpbGVwYXRoLCBjYWNoZVNldHRpbmdzKVxuICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHRcblxuICAvLyBiYXNlIGNhc2VcbiAgaWYgKGRpciA9PT0gJy8nIHx8IGRpciA9PT0gJy4nIHx8IC9eW0EtWl06XFxcXCQvaS50ZXN0KGRpcikpIHtcbiAgICByZXN1bHQgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlsZW5hbWVzID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICAgIGlmIChmaWxlbmFtZXMuaW5kZXhPZihwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBmaWxlRXhpc3RzV2l0aENhc2VTeW5jKGRpciwgY2FjaGVTZXR0aW5ncylcbiAgICB9XG4gIH1cbiAgY2FjaGVQYXRoKGZpbGVwYXRoLCByZXN1bHQpXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGF0aXZlKG1vZHVsZVBhdGgsIHNvdXJjZUZpbGUsIHNldHRpbmdzKSB7XG5cbiAgY29uc3Qgc291cmNlRGlyID0gcGF0aC5kaXJuYW1lKHNvdXJjZUZpbGUpXG4gICAgICAsIGNhY2hlS2V5ID0gc291cmNlRGlyICsgaGFzaE9iamVjdChzZXR0aW5ncykgKyBtb2R1bGVQYXRoXG5cbiAgY29uc3QgY2FjaGVTZXR0aW5ncyA9IGFzc2lnbih7XG4gICAgbGlmZXRpbWU6IDMwLCAgLy8gc2Vjb25kc1xuICB9LCBzZXR0aW5nc1snaW1wb3J0L2NhY2hlJ10pXG5cbiAgLy8gcGFyc2UgaW5maW5pdHlcbiAgaWYgKGNhY2hlU2V0dGluZ3MubGlmZXRpbWUgPT09ICfiiJ4nIHx8IGNhY2hlU2V0dGluZ3MubGlmZXRpbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICBjYWNoZVNldHRpbmdzLmxpZmV0aW1lID0gSW5maW5pdHlcbiAgfVxuXG4gIGNvbnN0IGNhY2hlZFBhdGggPSBjaGVja0NhY2hlKGNhY2hlS2V5LCBjYWNoZVNldHRpbmdzKVxuICBpZiAoY2FjaGVkUGF0aCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gY2FjaGVkUGF0aFxuXG4gIGZ1bmN0aW9uIGNhY2hlKHJlc29sdmVkUGF0aCkge1xuICAgIGNhY2hlUGF0aChjYWNoZUtleSwgcmVzb2x2ZWRQYXRoKVxuICAgIHJldHVybiByZXNvbHZlZFBhdGhcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhSZXNvbHZlcihyZXNvbHZlciwgY29uZmlnKSB7XG5cbiAgICBmdW5jdGlvbiB2MSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZXIucmVzb2x2ZUltcG9ydChtb2R1bGVQYXRoLCBzb3VyY2VGaWxlLCBjb25maWcpXG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4geyBmb3VuZDogZmFsc2UgfVxuICAgICAgICByZXR1cm4geyBmb3VuZDogdHJ1ZSwgcGF0aDogcmVzb2x2ZWQgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7IGZvdW5kOiBmYWxzZSB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdjIoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShtb2R1bGVQYXRoLCBzb3VyY2VGaWxlLCBjb25maWcpXG4gICAgfVxuXG4gICAgc3dpdGNoIChyZXNvbHZlci5pbnRlcmZhY2VWZXJzaW9uKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB2MigpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB2MSgpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29uZmlnUmVzb2x2ZXJzID0gKHNldHRpbmdzWydpbXBvcnQvcmVzb2x2ZXInXVxuICAgIHx8IHsgJ25vZGUnOiBzZXR0aW5nc1snaW1wb3J0L3Jlc29sdmUnXSB9KSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgY29uc3QgcmVzb2x2ZXJzID0gcmVzb2x2ZXJSZWR1Y2VyKGNvbmZpZ1Jlc29sdmVycywgbmV3IE1hcCgpKVxuXG4gIGZvciAobGV0IFtuYW1lLCBjb25maWddIG9mIHJlc29sdmVycykge1xuICAgIGNvbnN0IHJlc29sdmVyID0gcmVxdWlyZVJlc29sdmVyKG5hbWUsIHNvdXJjZUZpbGUpXG5cbiAgICBsZXQgeyBwYXRoOiBmdWxsUGF0aCwgZm91bmQgfSA9IHdpdGhSZXNvbHZlcihyZXNvbHZlciwgY29uZmlnKVxuXG4gICAgLy8gcmVzb2x2ZXJzIGltcGx5IGZpbGUgZXhpc3RlbmNlLCB0aGlzIGRvdWJsZS1jaGVjayBqdXN0IGVuc3VyZXMgdGhlIGNhc2UgbWF0Y2hlc1xuICAgIGlmIChmb3VuZCAmJiAhZmlsZUV4aXN0c1dpdGhDYXNlU3luYyhmdWxsUGF0aCwgY2FjaGVTZXR0aW5ncykpIHtcbiAgICAgIC8vIHJlamVjdCByZXNvbHZlZCBwYXRoXG4gICAgICBmdWxsUGF0aCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIGNhY2hlKGZ1bGxQYXRoKVxuICB9XG5cbiAgcmV0dXJuIGNhY2hlKHVuZGVmaW5lZClcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZXJSZWR1Y2VyKHJlc29sdmVycywgbWFwKSB7XG4gIGlmIChyZXNvbHZlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJlc29sdmVycy5mb3JFYWNoKHIgPT4gcmVzb2x2ZXJSZWR1Y2VyKHIsIG1hcCkpXG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNvbHZlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbWFwLnNldChyZXNvbHZlcnMsIG51bGwpXG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNvbHZlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJlc29sdmVycykge1xuICAgICAgbWFwLnNldChrZXksIHJlc29sdmVyc1trZXldKVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVzb2x2ZXIgY29uZmlnJylcbn1cblxuZnVuY3Rpb24gcmVxdWlyZVJlc29sdmVyKG5hbWUsIHNvdXJjZUZpbGUpIHtcbiAgLy8gVHJ5IHRvIHJlc29sdmUgcGFja2FnZSB3aXRoIGNvbnZlbnRpb25hbCBuYW1lXG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoYGVzbGludC1pbXBvcnQtcmVzb2x2ZXItJHtuYW1lfWApXG4gIH0gY2F0Y2ggKGVycikgeyAvKiBjb250aW51ZSAqLyB9XG5cbiAgLy8gVHJ5IHRvIHJlc29sdmUgcGFja2FnZSB3aXRoIGN1c3RvbSBuYW1lIChAbXlvcmcvcmVzb2x2ZXItbmFtZSlcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZShuYW1lKVxuICB9IGNhdGNoIChlcnIpIHsgLyogY29udGludWUgKi8gfVxuXG4gIC8vIFRyeSB0byByZXNvbHZlIHBhY2thZ2Ugd2l0aCBwYXRoLCByZWxhdGl2ZSB0byBjbG9zZXN0IHBhY2thZ2UuanNvblxuICAvLyBvciBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZURpciA9IHBrZ0Rpci5zeW5jKHNvdXJjZUZpbGUpIHx8IHByb2Nlc3MuY3dkKClcbiAgICAvLyBhYnNvbHV0ZSBwYXRocyBpZ25vcmUgYmFzZSwgc28gdGhpcyBjb3ZlcnMgYm90aFxuICAgIHJldHVybiByZXF1aXJlKHBhdGgucmVzb2x2ZShiYXNlRGlyLCBuYW1lKSlcbiAgfSBjYXRjaCAoZXJyKSB7IC8qIGNvbnRpbnVlICovIH1cblxuICAvLyBhbGwgZWxzZSBmYWlsZWRcbiAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gbG9hZCByZXNvbHZlciBcIiR7bmFtZX1cIi5gKVxufVxuXG5jb25zdCBlcnJvcmVkQ29udGV4dHMgPSBuZXcgU2V0KClcblxuLyoqXG4gKiBHaXZlblxuICogQHBhcmFtICB7c3RyaW5nfSBwIC0gbW9kdWxlIHBhdGhcbiAqIEBwYXJhbSAge29iamVjdH0gY29udGV4dCAtIEVTTGludCBjb250ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gdGhlIGZ1bGwgbW9kdWxlIGZpbGVzeXN0ZW0gcGF0aDtcbiAqICAgICAgICAgICAgICAgICAgICBudWxsIGlmIHBhY2thZ2UgaXMgY29yZTtcbiAqICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc29sdmUocCwgY29udGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiByZWxhdGl2ZSggcFxuICAgICAgICAgICAgICAgICAgICwgY29udGV4dC5nZXRGaWxlbmFtZSgpXG4gICAgICAgICAgICAgICAgICAgLCBjb250ZXh0LnNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWVycm9yZWRDb250ZXh0cy5oYXMoY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgbWVzc2FnZTogYFJlc29sdmUgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgbG9jOiB7IGxpbmU6IDEsIGNvbDogMCB9LFxuICAgICAgfSlcbiAgICAgIGVycm9yZWRDb250ZXh0cy5hZGQoY29udGV4dClcbiAgICB9XG4gIH1cbn1cbnJlc29sdmUucmVsYXRpdmUgPSByZWxhdGl2ZVxuXG5cbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nXG5mdW5jdGlvbiBoYXNoT2JqZWN0KG9iamVjdCkge1xuICBjb25zdCBzZXR0aW5nc1NoYXN1bSA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICBzZXR0aW5nc1NoYXN1bS51cGRhdGUoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSlcbiAgcmV0dXJuIHNldHRpbmdzU2hhc3VtLmRpZ2VzdCgnaGV4Jylcbn1cbiJdfQ==